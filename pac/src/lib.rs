#![doc = "Peripheral access API for MAX78000 microcontrollers (generated using svd2rust v0.34.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.34.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn PF_IRQ();
    fn WDT0_IRQ();
    fn Reserved18();
    fn RTC_IRQ();
    fn TRNG_IRQ();
    fn TMR0_IRQ();
    fn TMR1_IRQ();
    fn TMR2_IRQ();
    fn TMR3_IRQ();
    fn TMR4_IRQ();
    fn TMR5_IRQ();
    fn Reserved27();
    fn Reserved28();
    fn I2C0_IRQ();
    fn UART0_IRQ();
    fn UART1_IRQ();
    fn SPI1_IRQ();
    fn Reserved33();
    fn Reserved34();
    fn Reserved35();
    fn ADC_IRQ();
    fn Reserved37();
    fn Reserved38();
    fn FLC0_IRQ();
    fn GPIO0_IRQ();
    fn GPIO1_IRQ();
    fn GPIO2_IRQ();
    fn Reserved43();
    fn DMA0_IRQ();
    fn DMA1_IRQ();
    fn DMA2_IRQ();
    fn DMA3_IRQ();
    fn Reserved48();
    fn Reserved49();
    fn UART2_IRQ();
    fn Reserved51();
    fn I2C1_IRQ();
    fn Reserved53();
    fn Reserved54();
    fn Reserved55();
    fn Reserved56();
    fn Reserved57();
    fn Reserved58();
    fn Reserved59();
    fn Reserved60();
    fn Reserved61();
    fn Reserved62();
    fn Reserved63();
    fn Reserved64();
    fn Reserved65();
    fn Reserved66();
    fn Reserved67();
    fn Reserved68();
    fn WUT_IRQ();
    fn GPIOWAKE_IRQ();
    fn Reserved71();
    fn SPI0_IRQ();
    fn WDT1_IRQ();
    fn Reserved74();
    fn PT_IRQ();
    fn Reserved76();
    fn Reserved77();
    fn I2C2_IRQ();
    fn RISCV_IRQ();
    fn Reserved80();
    fn Reserved81();
    fn Reserved82();
    fn OWM_IRQ();
    fn Reserved84();
    fn Reserved85();
    fn Reserved86();
    fn Reserved87();
    fn Reserved88();
    fn Reserved89();
    fn Reserved90();
    fn Reserved91();
    fn Reserved92();
    fn Reserved93();
    fn Reserved94();
    fn Reserved95();
    fn Reserved96();
    fn Reserved97();
    fn ECC_IRQ();
    fn DVS_IRQ();
    fn SIMO_IRQ();
    fn Reserved101();
    fn Reserved102();
    fn Reserved103();
    fn UART3_IRQ();
    fn Reserved105();
    fn Reserved106();
    fn PCIF_IRQ();
    fn Reserved108();
    fn Reserved109();
    fn Reserved110();
    fn Reserved111();
    fn Reserved112();
    fn AES_IRQ();
    fn Reserved114();
    fn I2S_IRQ();
    fn CNN_FIFO_IRQ();
    fn CNN_IRQ();
    fn Reserved118();
    fn LPCMP_IRQ();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 104] = [
    Vector { _handler: PF_IRQ },
    Vector { _handler: WDT0_IRQ },
    Vector {
        _handler: Reserved18,
    },
    Vector { _handler: RTC_IRQ },
    Vector { _handler: TRNG_IRQ },
    Vector { _handler: TMR0_IRQ },
    Vector { _handler: TMR1_IRQ },
    Vector { _handler: TMR2_IRQ },
    Vector { _handler: TMR3_IRQ },
    Vector { _handler: TMR4_IRQ },
    Vector { _handler: TMR5_IRQ },
    Vector {
        _handler: Reserved27,
    },
    Vector {
        _handler: Reserved28,
    },
    Vector { _handler: I2C0_IRQ },
    Vector {
        _handler: UART0_IRQ,
    },
    Vector {
        _handler: UART1_IRQ,
    },
    Vector { _handler: SPI1_IRQ },
    Vector {
        _handler: Reserved33,
    },
    Vector {
        _handler: Reserved34,
    },
    Vector {
        _handler: Reserved35,
    },
    Vector { _handler: ADC_IRQ },
    Vector {
        _handler: Reserved37,
    },
    Vector {
        _handler: Reserved38,
    },
    Vector { _handler: FLC0_IRQ },
    Vector {
        _handler: GPIO0_IRQ,
    },
    Vector {
        _handler: GPIO1_IRQ,
    },
    Vector {
        _handler: GPIO2_IRQ,
    },
    Vector {
        _handler: Reserved43,
    },
    Vector { _handler: DMA0_IRQ },
    Vector { _handler: DMA1_IRQ },
    Vector { _handler: DMA2_IRQ },
    Vector { _handler: DMA3_IRQ },
    Vector {
        _handler: Reserved48,
    },
    Vector {
        _handler: Reserved49,
    },
    Vector {
        _handler: UART2_IRQ,
    },
    Vector {
        _handler: Reserved51,
    },
    Vector { _handler: I2C1_IRQ },
    Vector {
        _handler: Reserved53,
    },
    Vector {
        _handler: Reserved54,
    },
    Vector {
        _handler: Reserved55,
    },
    Vector {
        _handler: Reserved56,
    },
    Vector {
        _handler: Reserved57,
    },
    Vector {
        _handler: Reserved58,
    },
    Vector {
        _handler: Reserved59,
    },
    Vector {
        _handler: Reserved60,
    },
    Vector {
        _handler: Reserved61,
    },
    Vector {
        _handler: Reserved62,
    },
    Vector {
        _handler: Reserved63,
    },
    Vector {
        _handler: Reserved64,
    },
    Vector {
        _handler: Reserved65,
    },
    Vector {
        _handler: Reserved66,
    },
    Vector {
        _handler: Reserved67,
    },
    Vector {
        _handler: Reserved68,
    },
    Vector { _handler: WUT_IRQ },
    Vector {
        _handler: GPIOWAKE_IRQ,
    },
    Vector {
        _handler: Reserved71,
    },
    Vector { _handler: SPI0_IRQ },
    Vector { _handler: WDT1_IRQ },
    Vector {
        _handler: Reserved74,
    },
    Vector { _handler: PT_IRQ },
    Vector {
        _handler: Reserved76,
    },
    Vector {
        _handler: Reserved77,
    },
    Vector { _handler: I2C2_IRQ },
    Vector {
        _handler: RISCV_IRQ,
    },
    Vector {
        _handler: Reserved80,
    },
    Vector {
        _handler: Reserved81,
    },
    Vector {
        _handler: Reserved82,
    },
    Vector { _handler: OWM_IRQ },
    Vector {
        _handler: Reserved84,
    },
    Vector {
        _handler: Reserved85,
    },
    Vector {
        _handler: Reserved86,
    },
    Vector {
        _handler: Reserved87,
    },
    Vector {
        _handler: Reserved88,
    },
    Vector {
        _handler: Reserved89,
    },
    Vector {
        _handler: Reserved90,
    },
    Vector {
        _handler: Reserved91,
    },
    Vector {
        _handler: Reserved92,
    },
    Vector {
        _handler: Reserved93,
    },
    Vector {
        _handler: Reserved94,
    },
    Vector {
        _handler: Reserved95,
    },
    Vector {
        _handler: Reserved96,
    },
    Vector {
        _handler: Reserved97,
    },
    Vector { _handler: ECC_IRQ },
    Vector { _handler: DVS_IRQ },
    Vector { _handler: SIMO_IRQ },
    Vector {
        _handler: Reserved101,
    },
    Vector {
        _handler: Reserved102,
    },
    Vector {
        _handler: Reserved103,
    },
    Vector {
        _handler: UART3_IRQ,
    },
    Vector {
        _handler: Reserved105,
    },
    Vector {
        _handler: Reserved106,
    },
    Vector { _handler: PCIF_IRQ },
    Vector {
        _handler: Reserved108,
    },
    Vector {
        _handler: Reserved109,
    },
    Vector {
        _handler: Reserved110,
    },
    Vector {
        _handler: Reserved111,
    },
    Vector {
        _handler: Reserved112,
    },
    Vector { _handler: AES_IRQ },
    Vector {
        _handler: Reserved114,
    },
    Vector { _handler: I2S_IRQ },
    Vector {
        _handler: CNN_FIFO_IRQ,
    },
    Vector { _handler: CNN_IRQ },
    Vector {
        _handler: Reserved118,
    },
    Vector {
        _handler: LPCMP_IRQ,
    },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - Power Fail Interrupt"]
    PF_IRQ = 0,
    #[doc = "1 - Windowed Watchdog Timer 0 Interrupt"]
    WDT0_IRQ = 1,
    #[doc = "2 - Reserved"]
    Reserved18 = 2,
    #[doc = "3 - Reserved"]
    RTC_IRQ = 3,
    #[doc = "4 - True Random Number Generator Interrupt"]
    TRNG_IRQ = 4,
    #[doc = "5 - Timer 0 Interrupt"]
    TMR0_IRQ = 5,
    #[doc = "6 - Timer 1 Interrupt"]
    TMR1_IRQ = 6,
    #[doc = "7 - Timer 2 Interrupt"]
    TMR2_IRQ = 7,
    #[doc = "8 - Timer 3 Interrupt"]
    TMR3_IRQ = 8,
    #[doc = "9 - Timer 4 (LPTMR0) Interrupt"]
    TMR4_IRQ = 9,
    #[doc = "10 - Timer 5 (LPTMR1) Interrupt"]
    TMR5_IRQ = 10,
    #[doc = "11 - Reserved"]
    Reserved27 = 11,
    #[doc = "12 - Reserved"]
    Reserved28 = 12,
    #[doc = "13 - I2C Port 0 Interrupt"]
    I2C0_IRQ = 13,
    #[doc = "14 - UART Port 0 Interrupt"]
    UART0_IRQ = 14,
    #[doc = "15 - UART Port 1 Interrupt"]
    UART1_IRQ = 15,
    #[doc = "16 - SPI Port 1 Interrupt"]
    SPI1_IRQ = 16,
    #[doc = "17 - Reserved"]
    Reserved33 = 17,
    #[doc = "18 - Reserved"]
    Reserved34 = 18,
    #[doc = "19 - Reserved"]
    Reserved35 = 19,
    #[doc = "20 - ADC Interrupt"]
    ADC_IRQ = 20,
    #[doc = "21 - Reserved"]
    Reserved37 = 21,
    #[doc = "22 - Reserved"]
    Reserved38 = 22,
    #[doc = "23 - Flash Controller 0 Interrupt"]
    FLC0_IRQ = 23,
    #[doc = "24 - GPIO Port 0 Interrupt"]
    GPIO0_IRQ = 24,
    #[doc = "25 - GPIO Port 1 Interrupt"]
    GPIO1_IRQ = 25,
    #[doc = "26 - GPIO Port 2 Interrupt"]
    GPIO2_IRQ = 26,
    #[doc = "27 - Reserved"]
    Reserved43 = 27,
    #[doc = "28 - DMA0 Interrupt"]
    DMA0_IRQ = 28,
    #[doc = "29 - DMA1 Interrupt"]
    DMA1_IRQ = 29,
    #[doc = "30 - DMA2 Interrupt"]
    DMA2_IRQ = 30,
    #[doc = "31 - DMA3 Interrupt"]
    DMA3_IRQ = 31,
    #[doc = "32 - Reserved"]
    Reserved48 = 32,
    #[doc = "33 - Reserved"]
    Reserved49 = 33,
    #[doc = "34 - UART Port 2 Interrupt"]
    UART2_IRQ = 34,
    #[doc = "35 - Reserved"]
    Reserved51 = 35,
    #[doc = "36 - I2C Port 1 Interrupt"]
    I2C1_IRQ = 36,
    #[doc = "37 - Reserved"]
    Reserved53 = 37,
    #[doc = "38 - Reserved"]
    Reserved54 = 38,
    #[doc = "39 - Reserved"]
    Reserved55 = 39,
    #[doc = "40 - Reserved"]
    Reserved56 = 40,
    #[doc = "41 - Reserved"]
    Reserved57 = 41,
    #[doc = "42 - Reserved"]
    Reserved58 = 42,
    #[doc = "43 - Reserved"]
    Reserved59 = 43,
    #[doc = "44 - Reserved"]
    Reserved60 = 44,
    #[doc = "45 - Reserved"]
    Reserved61 = 45,
    #[doc = "46 - Reserved"]
    Reserved62 = 46,
    #[doc = "47 - Reserved"]
    Reserved63 = 47,
    #[doc = "48 - Reserved"]
    Reserved64 = 48,
    #[doc = "49 - Reserved"]
    Reserved65 = 49,
    #[doc = "50 - Reserved"]
    Reserved66 = 50,
    #[doc = "51 - Reserved"]
    Reserved67 = 51,
    #[doc = "52 - Reserved"]
    Reserved68 = 52,
    #[doc = "53 - Wakeup Timer Interrupt"]
    WUT_IRQ = 53,
    #[doc = "54 - GPIO Wakeup Interrupt"]
    GPIOWAKE_IRQ = 54,
    #[doc = "55 - Reserved"]
    Reserved71 = 55,
    #[doc = "56 - SPI Port 0 Interrupt"]
    SPI0_IRQ = 56,
    #[doc = "57 - Low Power Watchdog Timer 0 (WDT1) Interrupt"]
    WDT1_IRQ = 57,
    #[doc = "58 - Reserved"]
    Reserved74 = 58,
    #[doc = "59 - Pulse Train Interrupt"]
    PT_IRQ = 59,
    #[doc = "60 - Reserved"]
    Reserved76 = 60,
    #[doc = "61 - Reserved"]
    Reserved77 = 61,
    #[doc = "62 - I2C Port 2 Interrupt"]
    I2C2_IRQ = 62,
    #[doc = "63 - CPU1 (RV32) Interrupt"]
    RISCV_IRQ = 63,
    #[doc = "64 - Reserved"]
    Reserved80 = 64,
    #[doc = "65 - Reserved"]
    Reserved81 = 65,
    #[doc = "66 - Reserved"]
    Reserved82 = 66,
    #[doc = "67 - 1-Wire Master Interrupt"]
    OWM_IRQ = 67,
    #[doc = "68 - Reserved"]
    Reserved84 = 68,
    #[doc = "69 - Reserved"]
    Reserved85 = 69,
    #[doc = "70 - Reserved"]
    Reserved86 = 70,
    #[doc = "71 - Reserved"]
    Reserved87 = 71,
    #[doc = "72 - Reserved"]
    Reserved88 = 72,
    #[doc = "73 - Reserved"]
    Reserved89 = 73,
    #[doc = "74 - Reserved"]
    Reserved90 = 74,
    #[doc = "75 - Reserved"]
    Reserved91 = 75,
    #[doc = "76 - Reserved"]
    Reserved92 = 76,
    #[doc = "77 - Reserved"]
    Reserved93 = 77,
    #[doc = "78 - Reserved"]
    Reserved94 = 78,
    #[doc = "79 - Reserved"]
    Reserved95 = 79,
    #[doc = "80 - Reserved"]
    Reserved96 = 80,
    #[doc = "81 - Reserved"]
    Reserved97 = 81,
    #[doc = "82 - Error Correction Coding Block Interrupt"]
    ECC_IRQ = 82,
    #[doc = "83 - Digital Voltage Scaling Interrupt"]
    DVS_IRQ = 83,
    #[doc = "84 - Single Input Multiple Output Interrupt"]
    SIMO_IRQ = 84,
    #[doc = "85 - Reserved"]
    Reserved101 = 85,
    #[doc = "86 - Reserved"]
    Reserved102 = 86,
    #[doc = "87 - Reserved"]
    Reserved103 = 87,
    #[doc = "88 - UART3 (LPUART0) Interrupt"]
    UART3_IRQ = 88,
    #[doc = "89 - Reserved"]
    Reserved105 = 89,
    #[doc = "90 - Reserved"]
    Reserved106 = 90,
    #[doc = "91 - Parallel Camera Interface Interrupt"]
    PCIF_IRQ = 91,
    #[doc = "92 - Reserved"]
    Reserved108 = 92,
    #[doc = "93 - Reserved"]
    Reserved109 = 93,
    #[doc = "94 - Reserved"]
    Reserved110 = 94,
    #[doc = "95 - Reserved"]
    Reserved111 = 95,
    #[doc = "96 - Reserved"]
    Reserved112 = 96,
    #[doc = "97 - AES Interrupt"]
    AES_IRQ = 97,
    #[doc = "98 - Reserved"]
    Reserved114 = 98,
    #[doc = "99 - I2S Interrupt"]
    I2S_IRQ = 99,
    #[doc = "100 - CNN FIFO Interrupt"]
    CNN_FIFO_IRQ = 100,
    #[doc = "101 - CNN Interrupt"]
    CNN_IRQ = 101,
    #[doc = "102 - Reserved"]
    Reserved118 = 102,
    #[doc = "103 - Low Power Comparator Interrupt"]
    LPCMP_IRQ = 103,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "10-bit Analog to Digital Converter"]
pub struct Adc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Adc {}
impl Adc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc::RegisterBlock = 0x4003_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Adc {
    type Target = adc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Adc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Adc").finish()
    }
}
#[doc = "10-bit Analog to Digital Converter"]
pub mod adc;
#[doc = "AES Keys."]
pub struct Aes {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Aes {}
impl Aes {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aes::RegisterBlock = 0x4000_7400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aes::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Aes {
    type Target = aes::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Aes {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Aes").finish()
    }
}
#[doc = "AES Keys."]
pub mod aes;
#[doc = "AES Key Registers."]
pub struct Aeskeys {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Aeskeys {}
impl Aeskeys {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aeskeys::RegisterBlock = 0x4000_7800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aeskeys::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Aeskeys {
    type Target = aeskeys::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Aeskeys {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Aeskeys").finish()
    }
}
#[doc = "AES Key Registers."]
pub mod aeskeys;
#[doc = "Parallel Camera Interface."]
pub struct Cameraif {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cameraif {}
impl Cameraif {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cameraif::RegisterBlock = 0x4000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cameraif::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cameraif {
    type Target = cameraif::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cameraif {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cameraif").finish()
    }
}
#[doc = "Parallel Camera Interface."]
pub mod cameraif;
#[doc = "CRC Registers."]
pub struct Crc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Crc {}
impl Crc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crc::RegisterBlock = 0x4000_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Crc {
    type Target = crc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Crc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Crc").finish()
    }
}
#[doc = "CRC Registers."]
pub mod crc;
#[doc = "DMA Controller Fully programmable, chaining capable DMA channels."]
pub struct Dma {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dma {}
impl Dma {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma::RegisterBlock = 0x4002_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dma {
    type Target = dma::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dma {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dma").finish()
    }
}
#[doc = "DMA Controller Fully programmable, chaining capable DMA channels."]
pub mod dma;
#[doc = "Dynamic Voltage Scaling"]
pub struct Dvs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dvs {}
impl Dvs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dvs::RegisterBlock = 0x4000_3c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dvs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dvs {
    type Target = dvs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dvs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dvs").finish()
    }
}
#[doc = "Dynamic Voltage Scaling"]
pub mod dvs;
#[doc = "Function Control Register."]
pub struct Fcr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fcr {}
impl Fcr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fcr::RegisterBlock = 0x4000_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fcr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fcr {
    type Target = fcr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fcr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fcr").finish()
    }
}
#[doc = "Function Control Register."]
pub mod fcr;
#[doc = "Flash Memory Control."]
pub struct Flc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Flc {}
impl Flc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const flc::RegisterBlock = 0x4002_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Flc {
    type Target = flc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Flc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flc").finish()
    }
}
#[doc = "Flash Memory Control."]
pub mod flc;
#[doc = "Global Control Registers."]
pub struct Gcr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gcr {}
impl Gcr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gcr::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gcr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gcr {
    type Target = gcr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gcr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gcr").finish()
    }
}
#[doc = "Global Control Registers."]
pub mod gcr;
#[doc = "Global Control Function Register."]
pub struct Gcfr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gcfr {}
impl Gcfr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gcfr::RegisterBlock = 0x4000_5800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gcfr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gcfr {
    type Target = gcfr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gcfr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gcfr").finish()
    }
}
#[doc = "Global Control Function Register."]
pub mod gcfr;
#[doc = "Individual I/O for each GPIO"]
pub struct Gpio0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio0 {}
impl Gpio0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio0 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio0").finish()
    }
}
#[doc = "Individual I/O for each GPIO"]
pub mod gpio0;
#[doc = "Individual I/O for each GPIO 1"]
pub struct Gpio1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio1 {}
impl Gpio1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio1 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio1").finish()
    }
}
#[doc = "Individual I/O for each GPIO 1"]
pub use self::gpio0 as gpio1;
#[doc = "Individual I/O for each GPIO 2"]
pub struct Gpio2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio2 {}
impl Gpio2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4008_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio2 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio2").finish()
    }
}
#[doc = "Individual I/O for each GPIO 2"]
pub use self::gpio0 as gpio2;
#[doc = "Inter-Integrated Circuit."]
pub struct I2c0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c0 {}
impl I2c0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x4001_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c0 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c0").finish()
    }
}
#[doc = "Inter-Integrated Circuit."]
pub mod i2c0;
#[doc = "Inter-Integrated Circuit. 1"]
pub struct I2c1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c1 {}
impl I2c1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x4001_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c1 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c1").finish()
    }
}
#[doc = "Inter-Integrated Circuit. 1"]
pub use self::i2c0 as i2c1;
#[doc = "Inter-Integrated Circuit. 2"]
pub struct I2c2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c2 {}
impl I2c2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x4001_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c2 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c2").finish()
    }
}
#[doc = "Inter-Integrated Circuit. 2"]
pub use self::i2c0 as i2c2;
#[doc = "Inter-IC Sound Interface."]
pub struct I2s {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2s {}
impl I2s {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2s::RegisterBlock = 0x4006_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2s {
    type Target = i2s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2s {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2s").finish()
    }
}
#[doc = "Inter-IC Sound Interface."]
pub mod i2s;
#[doc = "Instruction Cache Controller Registers"]
pub struct Icc0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Icc0 {}
impl Icc0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const icc0::RegisterBlock = 0x4002_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const icc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Icc0 {
    type Target = icc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Icc0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Icc0").finish()
    }
}
#[doc = "Instruction Cache Controller Registers"]
pub mod icc0;
#[doc = "Low Power Comparator"]
pub struct Lpcmp {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lpcmp {}
impl Lpcmp {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lpcmp::RegisterBlock = 0x4008_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lpcmp::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lpcmp {
    type Target = lpcmp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lpcmp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lpcmp").finish()
    }
}
#[doc = "Low Power Comparator"]
pub mod lpcmp;
#[doc = "Low Power Global Control."]
pub struct Lpgcr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lpgcr {}
impl Lpgcr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lpgcr::RegisterBlock = 0x4008_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lpgcr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lpgcr {
    type Target = lpgcr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lpgcr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lpgcr").finish()
    }
}
#[doc = "Low Power Global Control."]
pub mod lpgcr;
#[doc = "Misc Control."]
pub struct Mcr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcr {}
impl Mcr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcr::RegisterBlock = 0x4000_6c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcr {
    type Target = mcr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcr").finish()
    }
}
#[doc = "Misc Control."]
pub mod mcr;
#[doc = "1-Wire Master Interface."]
pub struct Owm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Owm {}
impl Owm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const owm::RegisterBlock = 0x4003_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const owm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Owm {
    type Target = owm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Owm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Owm").finish()
    }
}
#[doc = "1-Wire Master Interface."]
pub mod owm;
#[doc = "Pulse Train"]
pub struct Pt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pt {}
impl Pt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pt::RegisterBlock = 0x4003_c020 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pt {
    type Target = pt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pt").finish()
    }
}
#[doc = "Pulse Train"]
pub mod pt;
#[doc = "Pulse Train 1"]
pub struct Pt1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pt1 {}
impl Pt1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pt::RegisterBlock = 0x4003_c030 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pt1 {
    type Target = pt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pt1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pt1").finish()
    }
}
#[doc = "Pulse Train 1"]
pub use self::pt as pt1;
#[doc = "Pulse Train 2"]
pub struct Pt2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pt2 {}
impl Pt2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pt::RegisterBlock = 0x4003_c040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pt2 {
    type Target = pt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pt2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pt2").finish()
    }
}
#[doc = "Pulse Train 2"]
pub use self::pt as pt2;
#[doc = "Pulse Train 3"]
pub struct Pt3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pt3 {}
impl Pt3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pt::RegisterBlock = 0x4003_c050 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pt3 {
    type Target = pt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pt3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pt3").finish()
    }
}
#[doc = "Pulse Train 3"]
pub use self::pt as pt3;
#[doc = "Pulse Train Generation"]
pub struct Ptg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ptg {}
impl Ptg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ptg::RegisterBlock = 0x4003_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ptg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ptg {
    type Target = ptg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ptg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ptg").finish()
    }
}
#[doc = "Pulse Train Generation"]
pub mod ptg;
#[doc = "Power Sequencer / Low Power Control Register."]
pub struct Pwrseq {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwrseq {}
impl Pwrseq {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwrseq::RegisterBlock = 0x4000_6800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwrseq::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwrseq {
    type Target = pwrseq::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwrseq {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwrseq").finish()
    }
}
#[doc = "Power Sequencer / Low Power Control Register."]
pub mod pwrseq;
#[doc = "Real Time Clock and Alarm."]
pub struct Rtc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rtc {}
impl Rtc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc::RegisterBlock = 0x4000_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rtc {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rtc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rtc").finish()
    }
}
#[doc = "Real Time Clock and Alarm."]
pub mod rtc;
#[doc = "The Semaphore peripheral allows multiple cores in a system to cooperate when accessing shred resources. The peripheral contains eight semaphores that can be atomically set and cleared. It is left to the discretion of the software architect to decide how and when the semaphores are used and how they are allocated. Existing hardware does not have to be modified for this type of cooperative sharing, and the use of semaphores is exclusively within the software domain."]
pub struct Sema {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sema {}
impl Sema {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sema::RegisterBlock = 0x4003_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sema::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sema {
    type Target = sema::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sema {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sema").finish()
    }
}
#[doc = "The Semaphore peripheral allows multiple cores in a system to cooperate when accessing shred resources. The peripheral contains eight semaphores that can be atomically set and cleared. It is left to the discretion of the software architect to decide how and when the semaphores are used and how they are allocated. Existing hardware does not have to be modified for this type of cooperative sharing, and the use of semaphores is exclusively within the software domain."]
pub mod sema;
#[doc = "Single Inductor Multiple Output Switching Converter"]
pub struct Simo {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Simo {}
impl Simo {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const simo::RegisterBlock = 0x4000_4400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const simo::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Simo {
    type Target = simo::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Simo {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Simo").finish()
    }
}
#[doc = "Single Inductor Multiple Output Switching Converter"]
pub mod simo;
#[doc = "System Initialization Registers."]
pub struct Sir {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sir {}
impl Sir {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sir::RegisterBlock = 0x4000_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sir::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sir {
    type Target = sir::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sir {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sir").finish()
    }
}
#[doc = "System Initialization Registers."]
pub mod sir;
#[doc = "SPI peripheral."]
pub struct Spi0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi0 {}
impl Spi0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi0::RegisterBlock = 0x400b_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi0 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi0").finish()
    }
}
#[doc = "SPI peripheral."]
pub mod spi0;
#[doc = "SPI peripheral. 1"]
pub struct Spi1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi1 {}
impl Spi1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi0::RegisterBlock = 0x4004_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi1 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi1").finish()
    }
}
#[doc = "SPI peripheral. 1"]
pub use self::spi0 as spi1;
#[doc = "Low-Power Configurable Timer"]
pub struct Tmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Tmr {}
impl Tmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tmr::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tmr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Tmr {
    type Target = tmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Tmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr").finish()
    }
}
#[doc = "Low-Power Configurable Timer"]
pub mod tmr;
#[doc = "Low-Power Configurable Timer 1"]
pub struct Tmr1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Tmr1 {}
impl Tmr1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tmr::RegisterBlock = 0x4001_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tmr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Tmr1 {
    type Target = tmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Tmr1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr1").finish()
    }
}
#[doc = "Low-Power Configurable Timer 1"]
pub use self::tmr as tmr1;
#[doc = "Low-Power Configurable Timer 2"]
pub struct Tmr2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Tmr2 {}
impl Tmr2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tmr::RegisterBlock = 0x4001_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tmr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Tmr2 {
    type Target = tmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Tmr2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr2").finish()
    }
}
#[doc = "Low-Power Configurable Timer 2"]
pub use self::tmr as tmr2;
#[doc = "Low-Power Configurable Timer 3"]
pub struct Tmr3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Tmr3 {}
impl Tmr3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tmr::RegisterBlock = 0x4001_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tmr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Tmr3 {
    type Target = tmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Tmr3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr3").finish()
    }
}
#[doc = "Low-Power Configurable Timer 3"]
pub use self::tmr as tmr3;
#[doc = "Low-Power Configurable Timer 4"]
pub struct Tmr4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Tmr4 {}
impl Tmr4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tmr::RegisterBlock = 0x4008_0c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tmr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Tmr4 {
    type Target = tmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Tmr4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr4").finish()
    }
}
#[doc = "Low-Power Configurable Timer 4"]
pub use self::tmr as tmr4;
#[doc = "Low-Power Configurable Timer 5"]
pub struct Tmr5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Tmr5 {}
impl Tmr5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tmr::RegisterBlock = 0x4008_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tmr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Tmr5 {
    type Target = tmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Tmr5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr5").finish()
    }
}
#[doc = "Low-Power Configurable Timer 5"]
pub use self::tmr as tmr5;
#[doc = "Trim System Initilazation Registers"]
pub struct Trimsir {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Trimsir {}
impl Trimsir {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const trimsir::RegisterBlock = 0x4000_5400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const trimsir::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Trimsir {
    type Target = trimsir::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Trimsir {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Trimsir").finish()
    }
}
#[doc = "Trim System Initilazation Registers"]
pub mod trimsir;
#[doc = "Random Number Generator."]
pub struct Trng {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Trng {}
impl Trng {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const trng::RegisterBlock = 0x4004_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const trng::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Trng {
    type Target = trng::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Trng {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Trng").finish()
    }
}
#[doc = "Random Number Generator."]
pub mod trng;
#[doc = "UART Low Power Registers"]
pub struct Uart {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart {}
impl Uart {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0x4004_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart").finish()
    }
}
#[doc = "UART Low Power Registers"]
pub mod uart;
#[doc = "UART Low Power Registers 1"]
pub struct Uart1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart1 {}
impl Uart1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0x4004_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart1 {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart1").finish()
    }
}
#[doc = "UART Low Power Registers 1"]
pub use self::uart as uart1;
#[doc = "UART Low Power Registers 2"]
pub struct Uart2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart2 {}
impl Uart2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0x4004_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart2 {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart2").finish()
    }
}
#[doc = "UART Low Power Registers 2"]
pub use self::uart as uart2;
#[doc = "UART Low Power Registers 3"]
pub struct Uart3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart3 {}
impl Uart3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0x4008_1400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart3 {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart3").finish()
    }
}
#[doc = "UART Low Power Registers 3"]
pub use self::uart as uart3;
#[doc = "Windowed Watchdog Timer"]
pub struct Wdt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdt {}
impl Wdt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0x4000_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdt {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt").finish()
    }
}
#[doc = "Windowed Watchdog Timer"]
pub mod wdt;
#[doc = "Windowed Watchdog Timer 1"]
pub struct Wdt1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdt1 {}
impl Wdt1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0x4008_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdt1 {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdt1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt1").finish()
    }
}
#[doc = "Windowed Watchdog Timer 1"]
pub use self::wdt as wdt1;
#[doc = "32-bit reloadable timer that can be used for timing and wakeup."]
pub struct Wut {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wut {}
impl Wut {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wut::RegisterBlock = 0x4000_6400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wut::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wut {
    type Target = wut::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wut {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wut").finish()
    }
}
#[doc = "32-bit reloadable timer that can be used for timing and wakeup."]
pub mod wut;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "ADC"]
    pub adc: Adc,
    #[doc = "AES"]
    pub aes: Aes,
    #[doc = "AESKEYS"]
    pub aeskeys: Aeskeys,
    #[doc = "CAMERAIF"]
    pub cameraif: Cameraif,
    #[doc = "CRC"]
    pub crc: Crc,
    #[doc = "DMA"]
    pub dma: Dma,
    #[doc = "DVS"]
    pub dvs: Dvs,
    #[doc = "FCR"]
    pub fcr: Fcr,
    #[doc = "FLC"]
    pub flc: Flc,
    #[doc = "GCR"]
    pub gcr: Gcr,
    #[doc = "GCFR"]
    pub gcfr: Gcfr,
    #[doc = "GPIO0"]
    pub gpio0: Gpio0,
    #[doc = "GPIO1"]
    pub gpio1: Gpio1,
    #[doc = "GPIO2"]
    pub gpio2: Gpio2,
    #[doc = "I2C0"]
    pub i2c0: I2c0,
    #[doc = "I2C1"]
    pub i2c1: I2c1,
    #[doc = "I2C2"]
    pub i2c2: I2c2,
    #[doc = "I2S"]
    pub i2s: I2s,
    #[doc = "ICC0"]
    pub icc0: Icc0,
    #[doc = "LPCMP"]
    pub lpcmp: Lpcmp,
    #[doc = "LPGCR"]
    pub lpgcr: Lpgcr,
    #[doc = "MCR"]
    pub mcr: Mcr,
    #[doc = "OWM"]
    pub owm: Owm,
    #[doc = "PT"]
    pub pt: Pt,
    #[doc = "PT1"]
    pub pt1: Pt1,
    #[doc = "PT2"]
    pub pt2: Pt2,
    #[doc = "PT3"]
    pub pt3: Pt3,
    #[doc = "PTG"]
    pub ptg: Ptg,
    #[doc = "PWRSEQ"]
    pub pwrseq: Pwrseq,
    #[doc = "RTC"]
    pub rtc: Rtc,
    #[doc = "SEMA"]
    pub sema: Sema,
    #[doc = "SIMO"]
    pub simo: Simo,
    #[doc = "SIR"]
    pub sir: Sir,
    #[doc = "SPI0"]
    pub spi0: Spi0,
    #[doc = "SPI1"]
    pub spi1: Spi1,
    #[doc = "TMR"]
    pub tmr: Tmr,
    #[doc = "TMR1"]
    pub tmr1: Tmr1,
    #[doc = "TMR2"]
    pub tmr2: Tmr2,
    #[doc = "TMR3"]
    pub tmr3: Tmr3,
    #[doc = "TMR4"]
    pub tmr4: Tmr4,
    #[doc = "TMR5"]
    pub tmr5: Tmr5,
    #[doc = "TRIMSIR"]
    pub trimsir: Trimsir,
    #[doc = "TRNG"]
    pub trng: Trng,
    #[doc = "UART"]
    pub uart: Uart,
    #[doc = "UART1"]
    pub uart1: Uart1,
    #[doc = "UART2"]
    pub uart2: Uart2,
    #[doc = "UART3"]
    pub uart3: Uart3,
    #[doc = "WDT"]
    pub wdt: Wdt,
    #[doc = "WDT1"]
    pub wdt1: Wdt1,
    #[doc = "WUT"]
    pub wut: Wut,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            adc: Adc::steal(),
            aes: Aes::steal(),
            aeskeys: Aeskeys::steal(),
            cameraif: Cameraif::steal(),
            crc: Crc::steal(),
            dma: Dma::steal(),
            dvs: Dvs::steal(),
            fcr: Fcr::steal(),
            flc: Flc::steal(),
            gcr: Gcr::steal(),
            gcfr: Gcfr::steal(),
            gpio0: Gpio0::steal(),
            gpio1: Gpio1::steal(),
            gpio2: Gpio2::steal(),
            i2c0: I2c0::steal(),
            i2c1: I2c1::steal(),
            i2c2: I2c2::steal(),
            i2s: I2s::steal(),
            icc0: Icc0::steal(),
            lpcmp: Lpcmp::steal(),
            lpgcr: Lpgcr::steal(),
            mcr: Mcr::steal(),
            owm: Owm::steal(),
            pt: Pt::steal(),
            pt1: Pt1::steal(),
            pt2: Pt2::steal(),
            pt3: Pt3::steal(),
            ptg: Ptg::steal(),
            pwrseq: Pwrseq::steal(),
            rtc: Rtc::steal(),
            sema: Sema::steal(),
            simo: Simo::steal(),
            sir: Sir::steal(),
            spi0: Spi0::steal(),
            spi1: Spi1::steal(),
            tmr: Tmr::steal(),
            tmr1: Tmr1::steal(),
            tmr2: Tmr2::steal(),
            tmr3: Tmr3::steal(),
            tmr4: Tmr4::steal(),
            tmr5: Tmr5::steal(),
            trimsir: Trimsir::steal(),
            trng: Trng::steal(),
            uart: Uart::steal(),
            uart1: Uart1::steal(),
            uart2: Uart2::steal(),
            uart3: Uart3::steal(),
            wdt: Wdt::steal(),
            wdt1: Wdt1::steal(),
            wut: Wut::steal(),
        }
    }
}
